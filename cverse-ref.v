/**
 * This is an autogenerated netlist code from CircuitVerse. Verilog Code can be
 * tested on https://www.edaplayground.com/ using Icarus Verilog 0.9.7. This is an
 * experimental module and some manual changes make need to be done in order for
 * this to work.
 *
 * If you have any ideas/suggestions or bug fixes, raise an issue
 * on https://github.com/CircuitVerse/CircuitVerse/issues/new/choose
 */

/*
  Element Usage Report
    Input - 34 times
    TriState - 6 times
    Output - 32 times
    DflipFlop - 6 times
    Adder - 2 times
    ConstantVal - 1 times
    Multiplexer - 1 times
    Demultiplexer - 1 times
    TwoComplement - 1 times
    NotGate - 12 times
    JKflipFlop - 6 times
    Splitter - 10 times
    NandGate - 4 times
    AndGate - 8 times
    NorGate - 6 times
    OrGate - 6 times
    SubCircuit - 9 times
    Clock - 1 times
    HexDisplay - 2 times
    Rom - 1 times
    Power - 1 times
*/

/*
  Usage Instructions and Tips
    Labels - Ensure unique label names and avoid using verilog keywords
    Warnings - Connect all optional inputs to remove warnings
    Clock - Use a single global clock
*/

// Sample Testbench Code - Uncomment to use


module TestBench();

  reg clr, clk_0;

  wire [3:0] High, Low;

  Main DUT0(High, Low, clk_0, clr);

  always begin
    #10
    clk_0 = 0;
    #10
    clk_0 = 1;
  end

  initial begin
    clr = 0;

    #15
    $display("High = %b", High);
    $display("Low = %b", Low);

    #10
    $display("High = %b", High);
    $display("Low = %b", Low);

    $finish;

  end
endmodule



module program_counter(out, clk, inc, clr, pc_out_en);
  output [3:0] out;
  input clk, inc, clr, pc_out_en;
  wire [3:0] TriState_0_out, DflipFlop_0_Q, Adder_0_Sum, const_0;
  assign TriState_0_out = (pc_out_en!=0) ? DflipFlop_0_Q : 4'b?;
  assign out = TriState_0_out;
  DflipFlop #(4) DflipFlop_0(DflipFlop_0_Q, , clk, Adder_0_Sum, clr, , inc);
  assign Adder_0_Sum = DflipFlop_0_Q + const_0;
  assign const_0 = 4'b0001;
endmodule

module adder_subtractor(out, A, B, add_sub, out_en);
  output [7:0] out;
  input add_sub, out_en;
  input [7:0] A, B;
  wire [7:0] TriState_0_out, Multiplexer_0_out, Adder_0_Sum, Demultiplexer_0_out_0, Demultiplexer_0_out_1, TwoComplement_0_\2's_complement ;
  assign TriState_0_out = (out_en!=0) ? Adder_0_Sum : 8'b?;
  assign out = TriState_0_out;
  Multiplexer2 #(8) Multiplexer_0(Multiplexer_0_out, Demultiplexer_0_out_0, TwoComplement_0_\2's_complement , add_sub);
  assign Adder_0_Sum = A + Multiplexer_0_out;
  Demultiplexer2 #(8) Demultiplexer_0(Demultiplexer_0_out_0, Demultiplexer_0_out_1, B, add_sub);
  assign TwoComplement_0_\2's_complement  = ~Demultiplexer_0_out_1 + 1;
endmodule

module sap1_ring_counter(t1, t2, t3, t4, t5, t6, clr, \~clk );
  output t1,  t2,  t3,  t4,  t5,  t6;
  input clr, \~clk ;
  wire not_0_out, JKflipFlop_5_Q, JKflipFlop_5_Q_inv, JKflipFlop_0_Q, JKflipFlop_0_Q_inv, JKflipFlop_1_Q, JKflipFlop_1_Q_inv, JKflipFlop_2_Q, JKflipFlop_2_Q_inv, JKflipFlop_3_Q, JKflipFlop_3_Q_inv, JKflipFlop_4_Q, JKflipFlop_4_Q_inv;
  assign not_0_out = ~\~clk ;
  JKflipFlop JKflipFlop_5(JKflipFlop_5_Q, JKflipFlop_5_Q_inv, JKflipFlop_4_Q, JKflipFlop_4_Q_inv, not_0_out, clr, , );
  JKflipFlop JKflipFlop_0(JKflipFlop_0_Q, JKflipFlop_0_Q_inv, JKflipFlop_5_Q_inv, JKflipFlop_5_Q, not_0_out, clr, , );
  assign t1 = JKflipFlop_0_Q_inv;
  JKflipFlop JKflipFlop_1(JKflipFlop_1_Q, JKflipFlop_1_Q_inv, JKflipFlop_0_Q_inv, JKflipFlop_0_Q, not_0_out, clr, , );
  JKflipFlop JKflipFlop_2(JKflipFlop_2_Q, JKflipFlop_2_Q_inv, JKflipFlop_1_Q, JKflipFlop_1_Q_inv, not_0_out, clr, , );
  JKflipFlop JKflipFlop_3(JKflipFlop_3_Q, JKflipFlop_3_Q_inv, JKflipFlop_2_Q, JKflipFlop_2_Q_inv, not_0_out, clr, , );
  JKflipFlop JKflipFlop_4(JKflipFlop_4_Q, JKflipFlop_4_Q_inv, JKflipFlop_3_Q, JKflipFlop_3_Q_inv, not_0_out, clr, , );
  assign t5 = JKflipFlop_4_Q;
  assign t4 = JKflipFlop_3_Q;
  assign t3 = JKflipFlop_2_Q;
  assign t2 = JKflipFlop_1_Q;
  assign t6 = JKflipFlop_5_Q;
endmodule

module instruction_decoder(lda, add, sub, out, \~halt , \Op-code );
  output lda,  add,  sub,  out,  \~halt ;
  input [3:0] \Op-code ;
  wire nand_0_out, and_0_out, nor_2_out, nor_1_out, nor_0_out, not_1_out, not_2_out, not_0_out;

  assign nand_0_out = ~(\Op-code [1] & \Op-code [0] & \Op-code [2] & \Op-code [3]);
  assign \~halt  = nand_0_out;
  assign and_0_out = \Op-code [1] & not_2_out & \Op-code [2] & \Op-code [3];
  assign out = and_0_out;
  assign nor_2_out = ~(not_1_out | \Op-code [0] | \Op-code [2] | \Op-code [3]);
  assign sub = nor_2_out;
  assign nor_1_out = ~(\Op-code [1] | not_0_out | \Op-code [2] | \Op-code [3]);
  assign add = nor_1_out;
  assign nor_0_out = ~(\Op-code [1] | \Op-code [0] | \Op-code [2] | \Op-code [3]);
  assign lda = nor_0_out;
  assign not_1_out = ~\Op-code [1];
  assign not_2_out = ~\Op-code [0];
  assign not_0_out = ~\Op-code [0];
endmodule

module \~ld_mar_logic (\~ld_mar , add, lda, sub, t4, t1);
  output \~ld_mar ;
  input add, lda, sub, t4, t1;
  wire nor_0_out, and_0_out, or_0_out;
  assign nor_0_out = ~(and_0_out | t1);
  assign \~ld_mar  = nor_0_out;
  assign and_0_out = or_0_out & t4;
  assign or_0_out = add | lda | sub;
endmodule

module \~mem_out_en_logic (\~mem_out_en , add, lda, sub, t5, t3);
  output \~mem_out_en ;
  input add, lda, sub, t5, t3;
  wire nor_0_out, and_0_out, or_0_out;
  assign nor_0_out = ~(and_0_out | t3);
  assign \~mem_out_en  = nor_0_out;
  assign and_0_out = or_0_out & t5;
  assign or_0_out = add | lda | sub;
endmodule

module \~ir_out_en_logic (\~ir_out_en , add, lda, sub, t4);
  output \~ir_out_en ;
  input add, lda, sub, t4;
  wire nand_0_out, or_0_out;
  assign nand_0_out = ~(or_0_out & t4);
  assign \~ir_out_en  = nand_0_out;
  assign or_0_out = add | lda | sub;
endmodule

module \~ld_acc_logic (\~ld_acc , t5, lda, t6, add, sub);
  output \~ld_acc ;
  input t5, lda, t6, add, sub;
  wire or_0_out, and_1_out, nor_0_out, and_0_out;
  assign or_0_out = add | sub;
  assign and_1_out = or_0_out & t6;
  assign nor_0_out = ~(and_0_out | and_1_out);
  assign \~ld_acc  = nor_0_out;
  assign and_0_out = t5 & lda;
endmodule







module controller_sequencer(inc, pc_out_en, \~ld_mar , \~mem_out_en , \~ir_out_en , \~ld_acc , acc_out_en, sub_add, subadd_out_en, \~ld_b_reg , \~ld_out_reg , \~halt , \~ld_ir , \Op-code , \~clk , clr);
  output inc,  pc_out_en,  \~ld_mar ,  \~mem_out_en ,  \~ir_out_en ,  \~ld_acc ,  acc_out_en,  sub_add,  subadd_out_en,  \~ld_b_reg ,  \~ld_out_reg ,  \~halt ,  \~ld_ir ;
  input \~clk , clr;
  input [3:0] \Op-code ;
  wire sap1_ring_counter_0_out_0, sap1_ring_counter_0_out_1, sap1_ring_counter_0_out_2, sap1_ring_counter_0_out_3, sap1_ring_counter_0_out_4, sap1_ring_counter_0_out_5, and_2_out, and_1_out, \~ld_acc_logic_5_out , nand_0_out, \~mem_out_en_logic_3_out , nand_1_out, and_0_out, \~ir_out_en_logic_4_out , \~ld_mar_logic_2_out , not_0_out, instruction_decoder_1_out_0, instruction_decoder_1_out_1, instruction_decoder_1_out_2, instruction_decoder_1_out_3, instruction_decoder_1_out_4, or_1_out, or_0_out;
  sap1_ring_counter sap1_ring_counter_0(sap1_ring_counter_0_out_0, sap1_ring_counter_0_out_1, sap1_ring_counter_0_out_2, sap1_ring_counter_0_out_3, sap1_ring_counter_0_out_4, sap1_ring_counter_0_out_5, clr, \~clk );
  assign and_2_out = sap1_ring_counter_0_out_5 & or_0_out;
  assign subadd_out_en = and_2_out;
  assign and_1_out = sap1_ring_counter_0_out_5 & instruction_decoder_1_out_2;
  assign sub_add = and_1_out;
  \~ld_acc_logic  \~ld_acc_logic_5 (\~ld_acc_logic_5_out , sap1_ring_counter_0_out_4, instruction_decoder_1_out_0, sap1_ring_counter_0_out_5, instruction_decoder_1_out_1, instruction_decoder_1_out_2);
  assign \~ld_acc  = \~ld_acc_logic_5_out ;
  assign nand_0_out = ~(sap1_ring_counter_0_out_4 & or_1_out);
  assign \~ld_b_reg  = nand_0_out;
  \~mem_out_en_logic  \~mem_out_en_logic_3 (\~mem_out_en_logic_3_out , instruction_decoder_1_out_1, instruction_decoder_1_out_0, instruction_decoder_1_out_2, sap1_ring_counter_0_out_4, sap1_ring_counter_0_out_2);
  assign \~mem_out_en  = \~mem_out_en_logic_3_out ;
  assign nand_1_out = ~(sap1_ring_counter_0_out_3 & instruction_decoder_1_out_3);
  assign \~ld_out_reg  = nand_1_out;
  assign and_0_out = sap1_ring_counter_0_out_3 & instruction_decoder_1_out_3;
  assign acc_out_en = and_0_out;
  \~ir_out_en_logic  \~ir_out_en_logic_4 (\~ir_out_en_logic_4_out , instruction_decoder_1_out_1, instruction_decoder_1_out_0, instruction_decoder_1_out_2, sap1_ring_counter_0_out_3);
  assign \~ir_out_en  = \~ir_out_en_logic_4_out ;
  \~ld_mar_logic  \~ld_mar_logic_2 (\~ld_mar_logic_2_out , instruction_decoder_1_out_1, instruction_decoder_1_out_0, instruction_decoder_1_out_2, sap1_ring_counter_0_out_3, sap1_ring_counter_0_out_0);
  assign \~ld_mar  = \~ld_mar_logic_2_out ;
  assign not_0_out = ~sap1_ring_counter_0_out_2;
  assign \~ld_ir  = not_0_out;
  assign inc = sap1_ring_counter_0_out_1;
  assign pc_out_en = sap1_ring_counter_0_out_0;
  instruction_decoder instruction_decoder_1(instruction_decoder_1_out_0, instruction_decoder_1_out_1, instruction_decoder_1_out_2, instruction_decoder_1_out_3, instruction_decoder_1_out_4, \Op-code );
  assign \~halt  = instruction_decoder_1_out_4;
  assign or_1_out = instruction_decoder_1_out_1 | instruction_decoder_1_out_2;
  assign or_0_out = instruction_decoder_1_out_1 | instruction_decoder_1_out_2;
endmodule










module Main(High, Low, clk_0, clr);
  output [3:0] High, Low;
  input clr, clk_0;
  wire TriState_3_out, controller_sequencer_2_out_0, controller_sequencer_2_out_1, controller_sequencer_2_out_2, controller_sequencer_2_out_3, controller_sequencer_2_out_4, controller_sequencer_2_out_5, controller_sequencer_2_out_6, controller_sequencer_2_out_7, controller_sequencer_2_out_8, controller_sequencer_2_out_9, controller_sequencer_2_out_10, controller_sequencer_2_out_11, controller_sequencer_2_out_12, not_1_out, not_4_out, not_5_out, not_3_out, not_2_out, not_6_out, not_0_out, Power_0_out;
  wire [3:0] TriState_1_out, MAR_Q;
  wire [7:0] Output_register_Q, B_register_Q, adder_subtractor_1_out, Splitter_4_cmb, Splitter_3_cmb, Accumulator_Q, Splitter_6_cmb, Splitter_7_cmb, Splitter_1_cmb, IR_Q, Rom_0_DataOut, TriState_0_out;
  assign TriState_3_out = (controller_sequencer_2_out_11!=0) ? clk_0 : 1'b?;
  DflipFlop #(8) Output_register(Output_register_Q, , TriState_3_out, Splitter_7_cmb, clr, , not_4_out);


      always @ (*)
        $display("HexDisplay:HexDisplay_0=%d", Output_register_Q[7:4]);

      always @ (*)
        $display("HexDisplay:HexDisplay_1=%d", Output_register_Q[3:0]);
  DflipFlop #(8) B_register(B_register_Q, , TriState_3_out, Splitter_6_cmb, clr, , not_5_out);
  adder_subtractor adder_subtractor_1(adder_subtractor_1_out, Accumulator_Q, B_register_Q, controller_sequencer_2_out_7, controller_sequencer_2_out_8);

  assign Splitter_4_cmb = {TriState_0_out[7:4],TriState_0_out[3:0]};
  assign Splitter_3_cmb = {TriState_0_out[7:4],TriState_0_out[3:0]};
  DflipFlop #(8) Accumulator(Accumulator_Q, , TriState_3_out, Splitter_3_cmb, clr, , not_3_out);
  assign Splitter_4_cmb = (controller_sequencer_2_out_6!=0) ? Accumulator_Q : 8'b?;
  assign High = TriState_0_out[7:4];
  assign Splitter_6_cmb = {TriState_0_out[7:4],TriState_0_out[3:0]};
  assign Splitter_7_cmb = {TriState_0_out[7:4],TriState_0_out[3:0]};
  assign Splitter_1_cmb = {TriState_0_out[7:4],TriState_0_out[3:0]};
  DflipFlop #(8) IR(IR_Q, , TriState_3_out, Splitter_1_cmb, clr, , not_1_out);

  controller_sequencer controller_sequencer_2(controller_sequencer_2_out_0, controller_sequencer_2_out_1, controller_sequencer_2_out_2, controller_sequencer_2_out_3, controller_sequencer_2_out_4, controller_sequencer_2_out_5, controller_sequencer_2_out_6, controller_sequencer_2_out_7, controller_sequencer_2_out_8, controller_sequencer_2_out_9, controller_sequencer_2_out_10, controller_sequencer_2_out_11, controller_sequencer_2_out_12, IR_Q[7:4], TriState_3_out, clr);
  assign not_1_out = ~controller_sequencer_2_out_12;
  assign not_4_out = ~controller_sequencer_2_out_10;
  assign not_5_out = ~controller_sequencer_2_out_9;
  assign not_3_out = ~controller_sequencer_2_out_5;
  assign not_2_out = ~controller_sequencer_2_out_4;
  assign TriState_0_out[3:0] = (not_2_out!=0) ? IR_Q[3:0] : 4'b?;
  assign Low = TriState_0_out[3:0];
  DflipFlop #(4) MAR(MAR_Q, , TriState_3_out, TriState_0_out[3:0], clr, , not_0_out);
  Rom0 Rom_0(Rom_0_DataOut, MAR_Q, Power_0_out);
  assign TriState_0_out = (not_6_out!=0) ? Rom_0_DataOut : 8'b?;

  assign not_6_out = ~controller_sequencer_2_out_3;
  assign not_0_out = ~controller_sequencer_2_out_2;
  program_counter program_counter_0(TriState_0_out[3:0], TriState_3_out, controller_sequencer_2_out_0, clr, controller_sequencer_2_out_1);
  assign Power_0_out = ~1'b0;
endmodule

module DflipFlop(q, q_inv, clk, d, a_rst, pre, en);
    parameter WIDTH = 1;
    output reg [WIDTH-1:0] q, q_inv;
    input clk, a_rst, pre, en;
    input [WIDTH-1:0] d;

    always @ (posedge clk or posedge a_rst)
    if (a_rst) begin
        q <= 'b0;
        q_inv <= 'b1;
    end else if (en == 0) ;
    else begin
        q <= d;
        q_inv <= ~d;
    end
endmodule

module Multiplexer2(out, in0, in1, sel);
  parameter WIDTH = 1;
  output reg [WIDTH-1:0] out;
  input [WIDTH-1:0] in0, in1;
  input [0:0] sel;

  always @ (*)
    case (sel)
      0 : out = in0;
      1 : out = in1;
    endcase
endmodule


module Demultiplexer2(out0, out1, in, sel);
  parameter WIDTH = 1;
  output reg [WIDTH-1:0] out0, out1;
  input [WIDTH-1:0] in;
  input [0:0] sel;

  always @ (*) begin
    out0 = 0;
    out1 = 0;
    case (sel)
      0 : out0 = in;
      1 : out1 = in;
    endcase
  end
endmodule

    module Rom0(dout, addr, en);
    parameter WIDTH = 8;
    parameter ADDR = 4;
    output reg [WIDTH-1:0] dout;
    input [ADDR-1:0] addr;
    input en;

    always @ (*) begin
        if (en == 0)
        dout = {WIDTH{1'bz}};
        else
        case (addr)
            0 : dout = 8;
        1 : dout = 25;
        2 : dout = 238;
        3 : dout = 255;
        4 : dout = 0;
        5 : dout = 0;
        6 : dout = 0;
        7 : dout = 0;
        8 : dout = 8;
        9 : dout = 1;
        10 : dout = 0;
        11 : dout = 0;
        12 : dout = 0;
        13 : dout = 0;
        14 : dout = 0;
        15 : dout = 0;
      endcase
    end
    endmodule

